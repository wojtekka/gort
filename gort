#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Gort v0.1
# Wojtek Kaniewski <wojtekka@toxygen.net>
# Public Domain
#
# Some code from http://code.activestate.com/recipes/66012/ by JÃ¼rgen Hermann

import os, sys, socket, signal, string, re, time, select, struct, getopt

from SocketServer import ThreadingTCPServer, BaseRequestHandler
from threading import *
from ConfigParser import ConfigParser, NoOptionError, NoSectionError

config_file = "gort.conf"
log_file = "gort.log"
log_indent = "    "

class Rule:
	"""Stores information about one packet mangling rule."""

	def __init__(self, match, replace, replies = None, state = None, new_state = None):
		self.match = match
		self.replace = replace
		self.replies = replies
		self.state = state
		self.new_state = new_state

class Log:
	"""Handles logging information, errors, packets etc."""

	def __init__(self, path = None):
		if path:
			self.file = open(path, 'a')
		else:
			self.file = None

	def log(self, text):
		"""Logs a line of information."""

		if self.file:
			self.file.write(text + "\n")
			self.file.flush()
		else:
			print text

	def timestamp(self):
		"""Creates time stamp."""

		now = time.time()

		return time.strftime("%H:%M:%S", time.localtime(now)) + ".%03d" % (int((now - int(now)) * 1000))

	def error(self, text):
		"""Logs error message."""

		self.log(self.timestamp() + " " + text)

	def info(self, text):
		"""Logs information message."""

		self.log(self.timestamp() + " " + text)

	def http(self, label, data):
		"""Logs HTTP data (request or reply)."""

		self.log(self.timestamp() + " " + label)

		for line in data.split("\n"):
			self.log(log_indent + line)

	def packet(self, label, data):
		"""Logs binary packet in hex and ASCII."""

		self.log(self.timestamp() + " " + label)

		hex = ""
		chars = ""
		offset = ""

		for i in range(len(data)):
			if i % 16 == 0:
				offset = log_indent + "%04x: " % i

			hex = hex + "%02x " % ord(data[i])

			if data[i] < ' ' or data[i] > '~':
				chars = chars + "."
			else:
				chars = chars + data[i]

			if i % 16 == 15:
				self.log(offset + hex + " " + chars)
				hex = ""
				chars = ""
				offset = ""
	
		if hex and chars and offset:
			self.log(offset + "%-48s" % hex + " " + chars)


class ExtendedConfigParser(ConfigParser):
	"""Adds basic exception handling to ConfigParser. Adds a method
	to parse IP address and store it in a tuple."""

	def getaddress(self, section, option):
		"""Gets IP address with port and stores it in a tuple.
		Returns None on exceptions."""

		text = self.get(section, option)
		if not text:
			return None
		tmp = string.split(text, ':')
		if len(tmp) != 2:
			return None
		try:
			return (tmp[0], int(tmp[1]))
		except:
			return None

	def get(self, section, option):
		"""Gets string value. Returns None on exceptions."""

		try:
			return ConfigParser.get(self, section, option)
		except (NoSectionError, NoOptionError):
			return None

	def getint(self, section, option):
		"""Gets integer value. Returns None on exceptions."""

		try:
			return ConfigParser.getint(self, section, option)
		except (NoSectionError, NoOptionError, TypeError):
			return None

	def getboolean(self, section, option):
		"""Gets boolean value. Returns None on exceptions."""

		try:
			return ConfigParser.getboolean(self, section, option)
		except (NoSectionError, NoOptionError, AttributeError):
			return None

class Config:
	"""Reads, stores and writes configuration."""

	appmsg_address = ("appmsg.gadu-gadu.pl", 80)
	local_address = (None, 0)
	server_address = (None, 0)
	saved_server_address = (None, 0)
	simulation = False

	gadu_port = 8074
	proxy_port = 8080
	hub_port = 80

	http_request_rules = []
	http_reply_rules = []
	client_packet_rules = []
	server_packet_rules = []

	def read(self, path):
		"""Reads configuration from a file.

		Arguments:
		- path: configuration file path"""

		config = ExtendedConfigParser()
		config.read(path)
		
		tmp = config.getaddress("general", "appmsg_address")
		if tmp:
			self.appmsg_address = tmp

		tmp = config.getaddress("general", "local_address")
		if tmp:
			self.local_address = tmp

		tmp = config.getaddress("general", "server_address")
		if tmp:
			self.server_address = tmp

		tmp = config.getboolean("general", "simulation")
		if tmp:
			self.simulation = tmp

		tmp = config.getint("general", "gadu_port")
		if tmp:
			self.gadu_port = tmp

		tmp = config.getint("general", "proxy_port")
		if tmp:
			self.proxy_port = tmp

		tmp = config.getint("general", "hub_port")
		if tmp:
			self.hub_port = tmp

		for section in config.sections():
			match = config.get(section, "match")
			replace = config.get(section, "replace")
			reply = config.get(section, "reply")

			try:
				if match:
					match = match.decode('string_escape')
				if replace:
					replace = replace.decode('string_escape')
				if reply:
					reply = reply.decode('string_escape')
			except ValueError:
				log.error("Invalid rule in section " + section)
				continue

			replies = []

			for (name, value) in config.items(section):
				if name[:5] != "reply":
					continue

				if not value:
					continue

				try:
					reply = value.decode('string_escape')
				except ValueError:
					log.error("Invalid rule in section " + section)
					continue

				replies.append(reply)

			state = config.get(section, "state")
			new_state = config.get(section, "new_state")

			rule = Rule(match, replace, replies, state, new_state)

			if section[:15] == "http_request::":
				self.http_request_rules.append(rule)

			if section[:13] == "http_reply::":
				self.http_reply_rules.append(rule)

			if section[:15] == "client_packet::":
				self.client_packet_rules.append(rule)

			if section[:15] == "server_packet::":
				self.server_packet_rules.append(rule)

		del config

	def write(self, path):
		"""Writes configuration to a file.

		Arguments:
		- path: configuration file path"""

		f = open(path, 'w+')

		f.write("[general]\n")

		if self.appmsg_address != ("appmsg.gadu-gadu.pl", 80):
			f.write("appmsg_address=%s:%d\n" % self.appmsg_address)

		if self.local_address != (None, 0):
			f.write("local_address=%s:%d\n" % self.local_address)

		if self.server_address != (None, 0):
			f.write("server_address=%s:%d\n" % self.server_address)

		if self.simulation:
			f.write("simulation=true\n")

		if self.gadu_port != 8074:
			f.write("gadu_port=%d\n" % (self.gadu_port))

		if self.proxy_port != 8080:
			f.write("proxy_port=%d\n" % (self.proxy_port))

		if self.hub_port != 80:
			f.write("hub_port=%d\n" % (self.hub_port))

		index = 1

		sections = [(self.http_request_rules, "http_request"),
			    (self.http_reply_rules, "http_reply"),
			    (self.client_packet_rules, "client_packet"),
			    (self.server_packet_rules, "server_packet")]

		for section in sections:
			(rules, name) = section
			for rule in rules:
				f.write("\n[%s::%d]\n" % (name, index))
				if rule.state:
					f.write("state=%s\n" % (rule.state))
				if rule.match:
					f.write("match=%s\n" % (rule.match.encode('string_escape')))
				if rule.replace:
					f.write("replace=%s\n" % (rule.replace.encode('string_escape')))
				if len(rule.replies) == 1:
					f.write("reply=%s\n" % (rule.replies[0].encode('string_escape')))
				else:
					idx = 1
					for reply in rule.replies:
						f.write("reply%d=%s\n" % (idx, reply.encode('string_escape')))
						idx = idx + 1

				if rule.new_state:
					f.write("new_state=%s\n" % (rule.new_state))
				index = index + 1

		f.close()

		return

	def get_server_address(self):
		"""Returns server address. If address is not forced in
		configuration, returns saved address retrieved from hub."""

		if self.server_address != (None, 0):
			return self.server_address
		else:
			return self.saved_server_address
	
	def set_server_address(self, address):
		"""Saves server address retrieved from original hub."""

		self.saved_server_address = address


class GaduHandler(BaseRequestHandler):
	"""Handles incoming Gadu-Gadu connection."""

	def mangle_packet(self, data, rules):
		"""Mangles incoming packet.

		Argument:
		- data: Packet data
		- rules: List of rules
		
		Returns a tuple containing mangled packet (or original packet
		if no rule matched) and reply to sender (or None if no rule
		matched)."""

		reply = None

		for rule in rules:
			if rule.state and not re.match(rule.state, self.state):
				continue

			if rule.match and not re.match(rule.match, data):
				continue

			if rule.match and rule.replace:
				data = re.sub(rule.match, rule.replace, data)

			for r in rule.replies:
				tmp = re.sub(rule.match, r, data)

				if tmp[4:8] == "####":
					reply_type = tmp[0:4]
					reply_data = tmp[8:]
					reply_length = struct.pack("<I", len(reply_data))
					tmp = reply_type + reply_length + reply_data

				if not reply:
					reply = tmp
				else:
					reply = reply + tmp

			if rule.new_state:
				log.info("Changing state from '%s' to '%s'" % (self.state, rule.new_state))
				self.state = rule.new_state

			break

		return (data, reply)


	def handle(self):
		"""Handles incoming connection."""

		self.state = "default"

		log.info("Client connected from %s:%d" % self.request.getpeername())

		if not config.simulation and config.get_server_address() == (None, 0):
			log.error("Server address unknown, closing connection")
			return

		client = self.request
		client_data = ""

		if config.simulation:
			(new_packet, reply) = self.mangle_packet("", config.client_packet_rules)

			if reply:
				log.packet("Sending simulated packet(s) to client", reply)
				client.send(reply)

		else:
			server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			server_data = ""

			address = config.get_server_address()

			log.info("Connecting to server at %s:%d" % address)
	
			try:
				server.connect(address)
			except socket.error, msg:
				log.error("Connection to server failed: %s" % (msg))
				return

			log.info("Connected to server")
		
		client_active = True

		while True:
			socks = []

			if client_active:
				socks.append(client)

			if not config.simulation:
				socks.append(server)

			(iwtd, owtd, ewtd) = select.select(socks, [], [])

			if client in iwtd:
				tmp = client.recv(4096)

				if not tmp:
					log.info("Client closed connection")
					break

				client_data = client_data + tmp

#				log.info("Received %d bytes from client" % len(tmp))

				while len(client_data) >= 8:
					(type, length) = struct.unpack("<II", client_data[:8])
					if len(client_data) < length + 8:
						break

					packet = client_data[:length+8]

					log.packet("Received packet from client", packet)

					(new_packet, reply) = self.mangle_packet(packet, config.client_packet_rules)

					if reply:
						log.packet("Sending simulated packet(s) to client", reply)
						client.send(reply)

					if not config.simulation and new_packet:
						if packet != new_packet:
							log.packet("Mangled packet from client", new_packet)
							packet = new_packet
	
						server.send(packet)

					client_data = client_data[length+8:]

			if not config.simulation and server in iwtd:
				tmp = server.recv(4096)

				if not tmp:
					log.info("Server closed connection")
					break

				server_data = server_data + tmp

#				log.info("Received %d bytes from server" % len(tmp))

				while len(server_data) >= 8:
					(type, length) = struct.unpack("<II", server_data[:8])
					if len(server_data) < length + 8:
						break

					packet = server_data[:length+8]

					log.packet("Received packet from server", packet)

					(new_packet, reply) = self.mangle_packet(packet, config.server_packet_rules)

					if reply:
						log.packet("Sending simulated packet to server", reply);
						server.send(reply)

					if new_packet:
						if packet != new_packet:
							log.packet("Mangled packet from server", new_packet)
							packet = new_packet

						log.info("Sending %d byte packet to client" % len(packet))

						client.send(packet)

					server_data = server_data[length+8:]

		client.close()

		if not config.simulation:
			server.close()

		return

class ProxyHubHandler(BaseRequestHandler, GaduHandler):
	"""Handles incoming proxy and hub connections."""

	def mangle_text(self, data, rules):
		"""Mangles text data.

		Arguments:
		- data: Text data
		- rules: List of rules"""

		for rule in rules:
			data = re.sub(rule.match, rule.replace, data)

		return data

	def handle(self):
		"""Handles incoming connection."""

		client_file = self.request.makefile("w+")

		# Store local address if not forced

		self.local_address = config.local_address

		if self.local_address == (None, 0):
			self.local_address = self.request.getsockname()

		# Read HTTP headers

		headers = []

		while True:
			line = client_file.readline()

			if not line:
				log.error("Client closed connection unexpectedly")
				return

			headers.append(line)
		
			if line == "\r\n":
				break

		# Handle HTTP method
	
		if len(headers) < 1:
			log.error("Empty request received from client")
			return

		if headers[0][:8] == "CONNECT ":
			# Pass connection to GaduHandler class

			client_file.write("HTTP/1.0 200 OK\r\n\r\n")
			client_file.flush()
			client_file.close() # self.request still valid
			GaduHandler.handle(self)
			return

		elif headers[0][:4] == "GET ":
			self.request.close() # client_file still valid
			pass

		else:
			log.error("Unsupported method received from client (" + headers[0].strip() + ")")
			return

		# Check if this is an appmsg request

		if headers[0].find("/appsvc/appmsg") != -1:
			hub_request = True
			request_label = "hub"
		else:
			hub_request = False
			request_label = "service"

		# Log original request

		log.http("Received hub request", "".join(headers))

		# Parse proxy request

		if headers[0][:11] == "GET http://":
			tmp = string.split(headers[0][11:], '/', 1)

			if len(tmp) != 2:
				log.error("Invalid proxy request received from client (" + headers[0].strip() + ")")
				return

			host = tmp[0]
			rest = "/" + tmp[1]

			host_found = False

			for i in range(len(headers)):
				if headers[i][:5].lower() == "host:":
					host_found = True

			if host_found == False:
				headers.append("Host: " + host + "\r\n")

			headers[0] = "GET " + rest

			if host.find(":") != -1:
				tmp = host.split(":", 1)
				address = (tmp[0], int(tmp[1]))
			else:
				address = (host, 80)
		else:
			address = config.appmsg_address

		# Create new request

		request = self.mangle_text("".join(headers), config.http_request_rules)

		# Make request to original server or simulate reply

		if config.simulation:
			if hub_request:
				(ip, port) = self.local_address
				reply = "HTTP/1.0 200 OK\r\n\r\n0 0 %s %s:%d\n" % (ip, ip, port)
			else:
				# Requests other than hub are unsupported

				reply = "HTTP/1.0 404 Not Found\r\nContent-type: text/html\r\n\r\n<H1>Not Found</H1>"

			request_label = "simulated " + request_label

		else:
			reply = self.get_reply(address, request, hub_request)

			if not reply:
				reply = "HTTP/1.0 503 Service Unavailable\r\nContent-type: text/html\r\n\r\n<H1>Service Unavailable</H1>"
				log.http("Sending reply", reply)
				client_file.write(reply)
				client_file.flush()
				return


		# Mangle reply

		reply = self.mangle_text(reply, config.http_reply_rules)

		# Send the reply to the client

		log.http("Sending " + request_label + " reply", reply)

		client_file.write(reply)
		client_file.flush()
		client_file.close()
	
		return

	def get_reply(self, address, request, hub = False):
		"""Connects to original server and gets reply.

		Arguments:
		- address: Server address
		- request: Complete request string
		- hub: Flag indicating hub connection

		Returns complete reply string or False on failure."""

		if hub:
			label = "hub"
		else:
			label = "service"

		# Connect to original server

		server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

		log.info("Connecting to " + label + " at %s:%d" % address)

		try:
			server.connect(address)
		except socket.error, msg:
			log.error("Connection to " + label + " failed: %s" % (msg))
			return False

		log.info("Connected to " + label)

		log.http("Sending request to " + label, request)

		server.send(request)
		server_file = server.makefile("r")
		server.close()

		# Read the reply. First the headers...

		headers = []
		body = []

		while True:
			line = server_file.readline()

			if not line:
				return False

			if line == "\r\n":
				break

			headers.append(line)

		if len(headers) < 1:
			return False

		# ...then the reply body

		while True:
			line = server_file.readline()

			if not line:
				break

			body.append(line)

		log.http("Received from " + label, "".join(headers) + "\r\n" + "".join(body))

		# If this is a hub reply, substitute server addres with our own

		if hub and headers[0][:12] == "HTTP/1.0 200":
			body[0] = self.change_server_address(body[0], self.local_address)

		# Return complete reply

		return "".join(headers) + "\r\n" + "".join(body)

	def change_server_address(self, line, address):
		"""Substitutes server address in hub reply. Stores original
		address for subsequent connections.

		Arguments:
		- line: First line of the reply
		- address: Local address

		Returns modified reply."""

		rule = re.compile("^(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(:(\d{1,5}))*")

		fields = string.split(line)

		(ip, port) = address

		# Substitute all occurences of IP addresses to our own

		for i in range(len(fields)):
			match = rule.match(fields[i])

			if not match:
				continue

			# Substitute but store the original

			if match.lastindex == 1:
				fields[i] = ip
				address = (match.group(1), 8074)
			else:
				fields[i] = ip + ":" + str(port)
				address = (match.group(1), int(match.group(3)))

			config.set_server_address(address)

		# Return result. Note that hub end the line with "\n"
		# not "\r\n".

		return " ".join(fields) + "\n"

class ThreadingReuseAddrTCPServer(ThreadingTCPServer):
	"""Sets allow_reuse_address in ThreadingTCPServer."""

	def __init__(self, bind, handler):
		self.allow_reuse_address = True
		ThreadingTCPServer.__init__(self, bind, handler)


class ServerThread(Thread):
	"""TCP server thread."""

	def __init__(self, port, handler, name):
		self.port = port
		self.handler = handler
		self.name = name
		Thread.__init__(self)

	def run(self):
		"""Thread body. Stars TCP server."""

		try:
			self.server = ThreadingReuseAddrTCPServer(('', self.port), self.handler)
			log.info("Started %s service at port %d" % (self.name, self.port))
			self.server.serve_forever()
		except:
			log.error("Unable to start %s service at port %d" % (self.name, self.port))


def main():
	gadu_thread = ServerThread(config.gadu_port, GaduHandler, "Gadu-Gadu")
	gadu_thread.start()

	proxy_thread = ServerThread(config.proxy_port, ProxyHubHandler, "proxy")
	proxy_thread.start()

	hub_thread = ServerThread(config.hub_port, ProxyHubHandler, "hub")
	hub_thread.start()


def daemonize():
	# do the UNIX double-fork magic, see Stevens' "Advanced 
	# Programming in the UNIX Environment" for details (ISBN 0201563177)
	try:
		pid = os.fork()
		if pid > 0:
			# exit first parent
			sys.exit(0)
	except OSError, e:
		print "Fork failed: %s" % (e.strerror)
		sys.exit(1)

	# decouple from parent environment
	os.chdir("/")
	os.setsid()
	os.umask(0)

	# do second fork
	try: 
		pid = os.fork() 
		if pid > 0:
			# exit from second parent, print eventual PID before
			sys.exit(0) 
	except OSError, e: 
		print "Fork failed: %s" % (e.strerror) 
		sys.exit(1) 


def usage():
	print "Usage: %s [OPTIONS]" % (sys.argv[0])
	print
	print "  -c, --config=FILE  Read configuration from FILE"
	print "  -l, --log=FILE     Write log to FILE"
	print "  -v, --verbose      Be verbose, don't fork"
	print "  -h, --help         Display this help and exit"
	print


if __name__ == "__main__":
	verbose = False

	try:
		opts, args = getopt.getopt(sys.argv[1:], "hc:l:v", ["help", "config=", "log=", "verbose"])
	except getopt.GetoptError, err:
		print str(err)
		usage()
		sys.exit(1)

	for opt, arg in opts:
		if opt in ("-h", "--help"):
			usage()
			sys.exit()
		elif opt in ("-v", "--verbose"):
			verbose = True
			log_file = None
		elif opt in ("-l", "--log"):
			log_file = arg
		elif opt in ("-c", "--config"):
			config_file = arg
		else:
			usage()
			sys.exit()

	log = Log(log_file)
	log.info("Gort started")

	config = Config()
	config.read(config_file)

	if config.simulation:
		log.info("Simulation mode")

	if not verbose:
		daemonize()

	main()

	if verbose:
		try:
			while True:
				time.sleep(3600)
		except KeyboardInterrupt:
			sys.exit()
